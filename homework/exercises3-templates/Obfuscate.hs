module Obfuscate where

import Data.Char
import Data.String


-- Von Neumanns proposed method of generating a pseudorandom
-- sequence of 4-digit numbers
middle_square :: Int -> Int
middle_square n = ((n*n) `div` 100) `mod` (10000) 


-- The sequence generated by seed 1111
rands :: [Int]
rands = iterate middle_square 2311

-- We don't use this method because we only need one seed.

seed = 9 :: Int -- Change me!

-- Algorithm for randomly shuffling a list with random input seed r
shuffle :: Int -> [a] -> [a]
shuffle r [] = []
shuffle r (a:as) = insert a (r `mod` length as) (shuffle r as) where
       insert a k [] = [a]
       insert a k (l:ls) = if k == 0 then a:(l:ls) else l:(insert a (k-1) ls)

-- Algorithm for randomly shuffling the inner elements of a list with random input seed k
shuffleInner :: Int -> [a] -> [a]
shuffleInner k [] = []
shuffleInner k [a] = [a]
shuffleInner k [a,b] = [a,b]
shuffleInner k (a:as) = (a : (shuffle k (init as))) ++ [last as]

cambridge :: String -> String
cambridge = recompose . (map (shuffleInner seed)) . words where
       recompose xss = init [ x | xs <- xss, x <- (xs ++ " ") ]

meme :: String
meme = "According to research at Cambridge university, it doesn't matter\
       \ what order the letters in a word are, the only important thing is\
       \ that the first and last letters are at the right place. The rest can\
       \ be a total mess and you can still read it without a problem. This is\
       \ because we do not read every letter by it self but the word as a whole."
